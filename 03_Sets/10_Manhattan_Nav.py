"""
Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню,
с запада на восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами.
Меньшие номера соответствуют западным авеню и южным улицам. Таким образом, можно построить
прямоугольную систему координат так, чтобы точка (x, y) лежала на пересечении x-ой авеню и y-ой улицы.
Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1, y1) до точки (x2, y2) нужно пройти
 |x2 − x1| + |y2 − y1| кварталов. Эта величина называется манхэттенским расстоянием между точками (x1, y1) и (x2, y2).

Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома,
который находится в точке (0, 0) и бежит по случайному маршруту.
Каждую минуту Миша либо остается на том же перекрестке, что и минуту назад, или перемещается на один квартал
в любом направлении. Чтобы не заблудиться Миша берет с собой навигатор, который каждые t минут говорит Мише,
в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может показать любую из точек,
манхэттенское расстояние от которых до Миши не превышает d.

Через t × n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил, что пора бежать домой.
Для этого он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.

---
Формат ввода
Первая строка входного файла содержит числа t, d и n (1 ≤ t ≤ 100, 1 ≤ d ≤ 100, 1 ≤ n ≤ 100).
Далее n строк описывают данные, полученные от навигатора. Строка номер i содержит числа x_i и y_i — данные, полученные
от навигатора через t_i минут от начала пробежки.

Формат вывода
В первой строке выходного файла выведите число m — число точек, в которых может находиться Миша.
Далее выведите m пар чисел — координаты точек. Точки можно вывести в произвольном порядке.
Гарантируется, что навигатор исправен и что существует по крайней мере одна точка, в которой может находиться Миша.
"""

# NON-OPTIMAL SOLUTION
# Less resource and time demanding algorithm would use 4 linear equations to depict area of premitted values.
t, d, n = map(int, input().split())

coords = []
for _ in range(n):
    coords.append(tuple(map(int, input().split())))

steps = t*n # макс сумма расстояний по координате

all_ends = set()
for x in range(0, steps+1):
    for y in range(steps-x, -steps+x-1, -1):
        all_ends.add((x, y))
for x in range(-1, -steps-1, -1):
    for y in range(steps+x, -steps-x-1, -1):
        all_ends.add((x, y))

# initial_diamond = set() #cоздадим ромб в начале координат
# initial_diamond.add((0, 0))
# for x in range(0, t+1):
#     for y in range(t-x, -t+x-1, -1):
#         initial_diamond.add((x, y))
# for x in range(-1, -t-1, -1):
#     for y in range(t+x, -t-x-1, -1):
#         initial_diamond.add((x, y))

new_ends = set()
fx, fy = coords[0]
for x in range(0, d+1):
    for y in range(d-x, -d+x-1, -1):
        new_ends.add((x+fx, y+fy))
for x in range(-1, -d-1, -1):
    for y in range(d+x, -d-x-1, -1):
        new_ends.add((x+fx, y+fy))
new_ends = new_ends.intersection(all_ends)

for fx, fy in coords[1:]:
    old_ends = new_ends.copy()
    for xx, yy in old_ends: # увеличиим ромб на t в каждую сторону
        for x in range(0, t+1):
            for y in range(t-x, -t+x-1, -1):
                new_ends.add((x+xx, y+yy))
        for x in range(-1, -t-1, -1):
            for y in range(t+x, -t-x-1, -1):
                new_ends.add((x+xx, y+yy))

    new_diamond = set() # область возможных значений после того, как стала известна координата
    for x in range(0, d+1):
        for y in range(d-x, -d+x-1, -1):
            new_diamond.add((x+fx, y+fy))
    for x in range(-1, -d-1, -1):
        for y in range(d+x, -d-x-1, -1):
            new_diamond.add((x+fx, y+fy))

    new_ends= new_ends.intersection(new_diamond)

fin = all_ends.intersection(new_ends)
print(len(fin))
for kek in fin:
    print(" ".join(map(str, kek)))
